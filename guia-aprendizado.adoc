= Guia de Aprendizado: Construindo a Torre de Hanói com Vue 3 e TypeScript
:toc: left
:toclevels: 3
:source-highlighter: highlight.js
:sectnums:

== Introdução: Aprendendo na Prática

Este documento é um guia passo a passo para entender como a aplicação Torre de Hanói foi construída. O objetivo é usar este projeto como um exemplo prático para ensinar os conceitos fundamentais do **Vue.js 3** e **TypeScript** a programadores que podem não ter familiaridade com eles.

Vamos desconstruir o projeto, começando pelo setup inicial e avançando gradualmente por componentes, reatividade e funcionalidades complexas.

== Parte 1: O Ambiente de Desenvolvimento

Antes de mergulhar no código, vamos entender as ferramentas que tornam o desenvolvimento moderno e eficiente.

=== Vite: O Servidor de Desenvolvimento Rápido

No passado, projetos JavaScript precisavam ser "empacotados" (bundled) a cada alteração, um processo que podia ser lento. O **Vite** resolve isso servindo os arquivos diretamente para o navegador, usando uma funcionalidade nativa chamada Módulos ES. O resultado é um servidor de desenvolvimento que inicia e atualiza quase instantaneamente.

No arquivo `package.json`, você vê os scripts que usam o Vite:

[source,json]
----
"scripts": {
  "dev": "vite", // Inicia o servidor de desenvolvimento
  "build": "vue-tsc && vite build", // Compila o projeto para produção
  "preview": "vite preview" // Visualiza a versão de produção
},
----

=== TypeScript: JavaScript com Superpoderes

O **TypeScript** é um "superset" do JavaScript, o que significa que todo código JavaScript é um código TypeScript válido. Sua principal vantagem é a **tipagem estática**. Em vez de descobrir erros em tempo de execução (quando o usuário já está vendo o bug), o TypeScript nos ajuda a encontrar erros durante o desenvolvimento.

Criamos um arquivo `src/types.ts` para centralizar nossas definições de tipo:

[source,typescript]
----
// src/types.ts
export interface Disco {
  id: number;
  tamanho: number;
  cor: string;
  largura: number;
}

// ... outras interfaces
----

Agora, sempre que precisarmos nos referir a um objeto de disco, podemos usar o tipo `Disco`. Se tentarmos criar um disco com um `id` que seja uma string em vez de um número, o TypeScript nos avisará imediatamente.

== Parte 2: Os Fundamentos do Vue 3

O Vue.js permite construir interfaces de usuário complexas a partir de pequenas peças chamadas **componentes**.

=== Anatomia de um Componente Vue (`.vue`)

Um Componente de Arquivo Único (Single File Component - SFC) do Vue encapsula o HTML, o JavaScript e o CSS de uma parte da interface em um único arquivo `.vue`.

Ele é dividido em três blocos:

1.  `<template>`: Contém o HTML do componente.
2.  `<script setup>`: Contém a lógica do componente (JavaScript/TypeScript).
3.  `<style scoped>`: Contém o CSS. A palavra `scoped` garante que os estilos aqui definidos se apliquem apenas a este componente, evitando conflitos.

=== `ref`: A Base da Reatividade

O conceito mais importante no Vue é a **reatividade**. Queremos que a interface do usuário "reaja" automaticamente às mudanças nos dados.

Para isso, usamos a função `ref`.

[source,typescript]
----
// Em App.vue
import { ref } from 'vue';

const movimentos = ref(0);
----

`ref(0)` cria uma "caixa" reativa em torno do valor 0. Agora, sempre que o valor dentro desta caixa mudar, qualquer parte do `<template>` que o utiliza será atualizada automaticamente.

Para acessar ou modificar o valor dentro da caixa, usamos a propriedade `.value`:

[source,typescript]
----
movimentos.value++; // O template será atualizado para mostrar o novo número
----

=== `props`: Passando Dados de Pai para Filho

Os componentes precisam se comunicar. A forma mais comum de um componente pai passar dados para um filho é através de `props` (propriedades).

Em `Tabuleiro.vue` (pai), passamos a lista de pinos para o `Pino.vue` (filho):

[source,html]
----
<!-- Tabuleiro.vue -->
<Pino
    v-for="(pino, indicePino) in pinos"
    :pino="pino" <!-- :pino é um atalho para v-bind:pino -->
/>
----

Dentro de `Pino.vue`, declaramos que esperamos receber essa `prop` usando `defineProps`. Aqui, usamos TypeScript para garantir que a `prop` `pino` seja um array de objetos do tipo `Disco`.

[source,typescript]
----
// Pino.vue
import type { Disco } from '../types.ts';

const props = defineProps<{
  pino: Disco[],
  // ... outras props
}>();

// Agora podemos usar props.pino no script e pino no template
----

=== `emit`: Comunicando de Filho para Pai

Se um filho precisa comunicar algo de volta para o pai (como um clique de botão), ele **emite um evento**.

Em `Controles.vue` (filho), quando o botão "Reiniciar" é clicado, ele emite um evento chamado `reiniciar`.

[source,html]
----
<!-- Controles.vue -->
<button @click="$emit('reiniciar')">Reiniciar</button>
<!-- @click é um atalho para v-on:click -->
----

Em `App.vue` (pai), ele "escuta" por esse evento e executa uma função quando ele acontece.

[source,html]
----
<!-- App.vue -->
<Controles @reiniciar="reiniciarJogo" />
----

Este fluxo de **"props para baixo, eventos para cima"** é o padrão de comunicação central no Vue e torna o fluxo de dados na aplicação muito claro e previsível.

== Parte 3: Construindo a Interface Passo a Passo

=== `computed`: Propriedades Derivadas

Às vezes, precisamos de um valor que é calculado a partir de outros dados reativos. Para isso, usamos **propriedades computadas** (`computed`). Elas são eficientes porque só são recalculadas quando uma de suas dependências muda.

Em `Disco.vue`, em vez de escrever uma lógica complexa no template para decidir o estilo do disco, criamos uma propriedade computada `estiloDisco`.

[source,typescript]
----
// Disco.vue
import { computed } from 'vue';

const estiloDisco = computed(() => {
  // Se o disco está animado, retorna um objeto de estilo.
  if (props.animado) {
    return { /* ... estilos para animação ... */ };
  }
  // Senão, retorna outro objeto de estilo.
  else {
    return { /* ... estilos para disco empilhado ... */ };
  }
});
----

Agora, no template, podemos simplesmente aplicar este estilo dinâmico:

[source,html]
----
<div class="disco" :style="estiloDisco">...</div>
----

=== `v-for`: Renderizando Listas

Para renderizar uma lista de itens, como os discos em um pino, usamos a diretiva `v-for`. Ela itera sobre um array e renderiza o elemento para cada item.

[source,html]
----
<!-- Pino.vue -->
<Disco
    v-for="(disco, i) in pino"
    :key="`${indicePino}-${disco.id}`"
    :tamanho="disco.tamanho"
    ...
/>
----

O `:key` é um atributo especial que o Vue usa para identificar cada item de forma única, otimizando a performance das atualizações.

== Parte 4: Funcionalidades Avançadas

=== `async/await` para Animações em Sequência

A função `moverAnimadoSimples` em `App.vue` é um ótimo exemplo de como orquestrar animações.

1.  A função é declarada como `async` e retorna uma `Promise`.
2.  Dentro dela, usamos `await new Promise(r => setTimeout(r, ...))` para pausar a execução da função pela duração da animação CSS.
3.  Isso permite que a função `autoResolver` chame `await moverAnimadoSimples(...)` e espere a animação terminar antes de prosseguir para o próximo movimento.

[source,typescript]
----
// App.vue
function moverAnimadoSimples(de, para) {
  return new Promise(async (resolve) => {
    // ... lógica para iniciar a animação ...

    // Espera a animação CSS terminar
    await new Promise(r => setTimeout(r, animacaoMovimento.tempoAnimacao));

    // ... lógica para finalizar o movimento nos dados ...
    resolve();
  });
}
----

== Conclusão

Este projeto, embora pequeno, demonstra os principais pilares do desenvolvimento com Vue 3 e TypeScript:

*   **Componentização**: Dividir a UI em peças lógicas e reutilizáveis.
*   **Reatividade**: Usar `ref` e `computed` para criar interfaces que se atualizam automaticamente.
*   **Fluxo de Dados Unidirecional**: Manter a aplicação previsível com `props` e `emits`.
*   **Tipagem Estática**: Aumentar a robustez e a manutenibilidade do código com TypeScript.

Esperamos que este guia tenha sido útil para desmistificar essas tecnologias e que sirva como um ponto de partida para explorar mais a fundo o ecossistema Vue.
